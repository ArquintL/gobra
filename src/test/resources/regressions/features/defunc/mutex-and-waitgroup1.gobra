// Any copyright is dedicated to the Public Domain.
// http://creativecommons.org/publicdomain/zero/1.0/

package pkg

import "sync"

pred sumSlice(s []int, sum int) {
	sumSliceIndex(s, sum, 0)
}

pred sumSliceIndex(s []int, sum int, startIndex int) {
	(startIndex >= len(s) ==> sum == 0) &&
		((startIndex < len(s)) ==> (acc(&s[startIndex], _) && sumSliceIndex(s, sum - s[startIndex], startIndex + 1)))
}

type Accum struct {
	sum *int
	m *sync.Mutex
	// TODO: add ghost slices that keep track of the counted nodes
}

pred AccInv(x *int) {
	acc(x)
}

// TODO: debug this
// requires acc(c) && acc(c.sum) && acc(c.m) && *(c.m) == sync.Mutex{}
requires acc(c) && acc(c.sum) && acc(c.m) && c.m.state == 0 && c.m.stema == 0
requires c.sum != nil
ensures acc(c) && c.m.LockP() && c.m.LockInv() == (AccInv!<c.sum!>)
func (c *Accum) Init() {
	fold AccInv!<c.sum!>()
	c.m.SetInv(AccInv!<c.sum!>)
}

// TODO: change names of vars and types
// TODO: define a specific predicate for the post condition
/* Creates a worker thread per element in the slice and concurrently computes the sum of all the elements */
func ParallelSum(s []int) (res int) {
	if len(s) == 0 {
		return 0
	}

	// { len(s) > 0 }
	count@ := 0
	m := &sync.Mutex{}
	c := &Accum{sum: &count, m: m}
	// { acc(c) && acc(c.sum) && acc(c.m) }
	c.Init()
	// { acc(c) && c.m.LockP() && c.m.LockInv() == AccInv!<c.sum!> }
	w := &sync.WaitGroup{}
	w.Init()
	// {
	//    acc(c) && c.m.LockP() &&
	//    c.m.LockInv() == AccInv!<c.sum!> &&
	//    w.WaitGroupP && !w.WaitMode()
	// }

	n := len(s)

	invariant i >= 0
	invariant i == 0 ==> w.WaitGroupP()
	// Martin suggested the following line instead of the previous one, with the goal of
	// deleting the invariant `i >= 0`. However, that is insufficient to prove the loop invariant
	// invariant i != 0 ==> acc(w.WaitGroupP(), 1/2) && acc(w.WaitGroupStarted(), 1/2)
	invariant i > 0 ==> acc(w.WaitGroupP(), 1/2) && acc(w.WaitGroupStarted(), 1/2)
	invariant i >= n ==> w.Token(PredTrue!<!>)
	invariant !w.WaitMode()
	invariant acc(c, _)
	invariant acc(c.m.LockP(), _) && c.m.LockInv() == AccInv!<c.sum!>;
	for i := 0; i < n; i++ {
		// { }
		w.Add(1, 1, 2, PredTrue!<!>)
		ghost if i == 0 {
			w.Start(1, 2, PredTrue!<!>)
		}
		ghost if i == n-1 {
			fold PredTrue!<!>()
			w.GenerateToken(PredTrue!<!>)
		}
		// { }
		go worker(w, c, s[i] /*, 1, n+1*/)
	}

	w.SetWaitMode(1, 2, 1, 2)
	w.Wait(1, 1, PredTrue!<!>)
	assert c.m.LockInv() == AccInv!<c.sum!>;
	c.m.Lock()
	unfold AccInv!<c.sum!>()
	res = *(c.sum) // TODO: maybe restructure the data in Accum to not have a pointer to int
	fold AccInv!<c.sum!>()
	c.m.Unlock()

	// Main correctness criteria
	// Goal: prove that, at this point, the value sum protected by the mutex has the sum of all elems of the array
	//simpleSum := SimpleSum(s)
	//assert res == simpleSum 

	return res
}

requires acc(accum, _)
requires acc(accum.m.LockP(), _) && accum.m.LockInv() == AccInv!<accum.sum!>;
requires w.UnitDebt(PredTrue!<!>)
func worker(w *sync.WaitGroup, accum *Accum, val int/*, ghost dividend int, ghost divisor int*/) {
	// { }
	accum.m.Lock()
	// { }
	unfold AccInv!<accum.sum!>()
	*(accum.sum) += val
	fold AccInv!<accum.sum!>()
	accum.m.Unlock()
	w.Done()
}

requires forall i int :: 0 <= i && i < len(s) ==> acc(&s[i], _)
ensures forall i int :: 0 <= i && i < len(s) ==> acc(&s[i], _)
ensures sumSlice(s, res)
func SimpleSum(s []int) (res int) {
	res = 0
	fold sumSliceIndex(s, 0, len(s))
	invariant -1 <= i && i < len(s)
	invariant forall j int :: 0 <= j && j < len(s) ==> acc(&s[j], _)
	invariant sumSliceIndex(s, res, i+1)
	for i:=len(s)-1; i>=0; i-- {
		res += *(&s[i])
		fold sumSliceIndex(s, res, i)
	}
	fold sumSlice(s, res)
}

// TODO: suggestion by linard: similar example to the one above where the user defines the
// number of chunks and a thread is created per chunk instead of per cell

// TODO: Martin's example of worker threads