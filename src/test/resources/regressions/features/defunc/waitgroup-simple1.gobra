// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.
//
// Copyright (c) 2011-2020 ETH Zurich.

package pkg

import "sync"

// TODO: remove all occurrences of sync.pred_true when PredTrue is added to the language

/* Generates n + 1 threads that execute the `worker` function */
requires n >= 0
func spawnThreads(n int) {
	// {}
	var wg *sync.WaitGroup = &sync.WaitGroup{}
	// { acc(wg) && *wg == WaitGroup{} }
	wg.Init()
	// { wg.WaitGroupP() && !wg.WaitMode() }
	wg.Add(1, 1, 1, sync.pred_true!<!>)
	// { wg.WaitGroupP() && !wg.WaitMode() && wg.UnitDebt(pred_true!<!>) }
	fold sync.pred_true!<!>()
	// { wg.WaitGroupP() && !wg.WaitMode() && wg.UnitDebt(pred_true!<!>) && pred_true!<!>() }
	wg.GenerateToken(sync.pred_true!<!>)
	// { wg.WaitGroupP() && !wg.WaitMode() && wg.UnitDebt(pred_true!<!>) && wg.Token(pred_true!<!>) }
	wg.Start(1, 2, sync.pred_true!<!>)
	// { acc(wg.WaitGroupP(), 1/2) && acc(wg.WaitGroupStarted(), 1/2) && !wg.WaitMode() && wg.UnitDebt(pred_true!<!>) && wg.Token(pred_true!<!>) }
	fold sync.pred_true!<!>()
	// { acc(wg.WaitGroupP(), 1/2) && acc(wg.WaitGroupStarted(), 1/2) && !wg.WaitMode() && wg.UnitDebt(pred_true!<!>) && wg.Token(pred_true!<!>) && pred_true!<!>() }
	go worker(-1, wg, sync.pred_true!<!>) // spawns first worker
	// { acc(wg.WaitGroupP(), 1/2) && acc(wg.WaitGroupStarted(), 1/2) && !wg.WaitMode() && wg.Token(pred_true!<!>) }

	invariant acc(wg.WaitGroupP(), 1/2)
	invariant acc(wg.WaitGroupStarted(), 1/2)
	invariant !wg.WaitMode()
	invariant acc(wg.Token(sync.pred_true!<!>), (i + 1)/1)
	for i := 0; i < n; i++ {
		// {
		//   acc(wg.WaitGroupP(), 1/2) &&
		//   acc(wg.WaitGroupStarted(), 1/2) &&
		//   !wg.WaitMode() &&
		//   acc(wg.Token(pred_true!<!>), i + 1) &&
		//   i < n
		// }
		wg.Add(1, 1, 2, sync.pred_true!<!>)
		// {
		//   acc(wg.WaitGroupP(), 1/2) &&
		//   acc(wg.WaitGroupStarted(), 1/2) &&
		//   !wg.WaitMode() &&
		//   acc(wg.Token(pred_true!<!>), i + 1) &&
		//   i < n &&
		//   g.UnitDebt(pred_true!<!>)
		// }
		fold sync.pred_true!<!>()
		// { same as above plus pred_true!<!>() }
		wg.GenerateToken(sync.pred_true!<!>)
		// {
		//   acc(wg.WaitGroupP(), 1/2) &&
		//   acc(wg.WaitGroupStarted(), 1/2) &&
		//   !wg.WaitMode() &&
		//   acc(wg.Token(pred_true!<!>), i + 2) && // permission increased by 1
		//   i < n &&
		//   wg.UnitDebt(pred_true!<!>)
		// }
		fold sync.pred_true!<!>()
		// { same as above plus pred_true!<!>() }
		go worker(i, wg, sync.pred_true!<!>)
		// {
		//   acc(wg.WaitGroupP(), 1/2) &&
		//   acc(wg.WaitGroupStarted(), 1/2) &&
		//   !wg.WaitMode() &&
		//   acc(wg.Token(pred_true!<!>), i + 2) && // this reverts to i + 1 when i is incremented in the end of the iteration
		//   i < n
		// }
	}

	// {
	//   acc(wg.WaitGroupP(), 1/2) &&
	//   acc(wg.WaitGroupStarted(), 1/2) &&
	//   !wg.WaitMode() &&
	//   acc(wg.Token(pred_true!<!>), n + 1) // slightly simplified
	// }
	wg.SetWaitMode(1, 2, 1, 2)
	// {
	//   wg.WaitGroupP() &&
	//   wg.WaitMode() &&
	//   acc(wg.Token(pred_true!<!>), n + 1)
	// }

	// This example is simple and we do not need to perform any token redistribution before calling wait. This is not
	// true in general
	wg.Wait(1, 1, sync.pred_true!<!>)
	// {
	//   wg.WaitGroupP() &&
	//   pred_true!<!>()
	// }
}

requires P() && wg.UnitDebt(P)
func worker(id int, wg *sync.WaitGroup, ghost P pred()) {
	// { P() && wg.UnitDebt(P) }
	wg.PayDebt(P)
	// { wg.UnitDebt(pred_true!<!>) }
	wg.Done()
	// { }
}