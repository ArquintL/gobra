// Any copyright is dedicated to the Public Domain.
// http://creativecommons.org/publicdomain/zero/1.0/

// ported verified operations on dense matrices from Viper

package main

type Matrix struct {
    values [][]int
}

pred matrix(m *Matrix) {
    acc(&m.values) &&
        (forall i int :: (0 <= i && i < len(m.values) ==> acc(&(m.values)[i]))) &&
        (forall i, j int :: (0 <= i && i < len(m.values) && 0 <= j && j < len((m.values)[i]) ==> acc(&(m.values)[i][j]))) &&
        (forall i int :: (0 <= i && i < len(m.values) ==> len((m.values)[i]) == len((m.values)[0])))
}

// number of rows
requires acc(matrix(m), _)
pure func (m *Matrix) lenX() int {
    return unfolding acc(matrix(m), _) in len(m.values)
}

// number of columns
requires acc(matrix(m), _)
pure func (m *Matrix) lenY() int {
    return unfolding acc(matrix(m), _) in len(m.values) == 0 ? 0 : len((m.values)[0])
}

requires acc(matrix(m), _)
requires 0 <= i && i < m.lenX()
requires 0 <= j && j < m.lenY()
pure func (m *Matrix) lookup(i, j int) (res int) {
    return unfolding acc(matrix(m), _) in (m.values)[i][j]
}

requires matrix(m)
ensures matrix(m)
ensures m.lenX() == old(m.lenX()) && m.lenY() == old(m.lenY())
ensures forall i, j int :: (0 <= i && i < m.lenX() && 0 <= j && j < m.lenY() ==> m.lookup(i, j) == old(m.lookup(i, j)) * z)
func (m *Matrix) multAlt(z int) {
    invariant matrix(m)
    invariant 0 <= x && x <= m.lenX()
    invariant m.lenX() == old(m.lenX()) && m.lenY() == old(m.lenY())
    invariant forall i, j int :: (0 <= i && i < x && 0 <= j && j < m.lenY() ==> m.lookup(i, j) == old(m.lookup(i, j)) * z)
    invariant forall i, j int :: (x <= i && i < m.lenX() && 0 <= j && j < m.lenY() ==> m.lookup(i, j) == old(m.lookup(i, j)))
    for x := 0; x < m.lenX(); x++ {
        invariant matrix(m)
        invariant 0 <= x && x < m.lenX()
        invariant 0 <= y && y <= m.lenY()
        invariant m.lenX() == old(m.lenX()) && m.lenY() == old(m.lenY())
        invariant forall i, j int :: (0 <= i && i < x && 0 <= j && j < m.lenY() ==> m.lookup(i, j) == old(m.lookup(i, j)) * z)
        invariant forall j int :: (0 <= j && j < y ==> m.lookup(x, j) == old(m.lookup(x, j)) * z)
        invariant forall j int :: (y <= j && j < m.lenY() ==> m.lookup(x, j) == old(m.lookup(x, j)))
        invariant forall i, j int :: (x < i && i < m.lenX() && 0 <= j && j < m.lenY() ==> m.lookup(i, j) == old(m.lookup(i, j)))
        for y := 0; y < m.lenY(); y++ {
            unfold matrix(m)
            (m.values)[x][y] = (m.values)[x][y] * z
            fold matrix(m)
        }
    }
}
