// Any copyright is dedicated to the Public Domain.
// http://creativecommons.org/publicdomain/zero/1.0/

// ported verified operations on sparse matrices from Viper

package main

type Entry struct {
    row int
    column int
    value int
}

type SparseMatrix struct {
    entry *Entry
    next *SparseMatrix
}

pred entry(e *Entry, r, c int) {
    acc(&e.row) && 0 <= e.row && e.row < r &&
    acc(&e.column) && 0 <= e.column && e.column < c &&
    acc(&e.value)
}

pred matrix(m *SparseMatrix, maxRow, maxColumn int) {
    m != nil ==>
        acc(&m.entry) && entry(m.entry, maxRow, maxColumn) &&
        acc(&m.next) && matrix(m.next, maxRow, maxColumn)
}

requires acc(matrix(m, maxRow, maxColumn), _)
pure func LookupL(m *SparseMatrix, maxRow, maxColumn, i, j int) int {
    return unfolding acc(matrix(m, maxRow, maxColumn), _) in (m == nil ? 0 : unfolding acc(entry(m.entry, maxRow, maxColumn), _) in (m.entry.row == i && m.entry.column == j) ? m.entry.value : LookupL(m.next, maxRow, maxColumn, i, j))
}

requires matrix(m, maxRow, maxColumn)
ensures matrix(m, maxRow, maxColumn)
ensures forall i, j int :: (0 <= i && i < maxRow && 0 <= j && j < maxColumn) ==> LookupL(m, maxRow, maxColumn, i, j) == old(LookupL(m, maxRow, maxColumn, i, j)) * z
func (m *SparseMatrix) mult(maxRow, maxColumn, z int) {
    unfold matrix(m, maxRow, maxColumn)
    if (m != nil) {
        m.next.mult(maxRow, maxColumn, z)
        unfold entry(m.entry, maxRow, maxColumn)
        m.entry.value = m.entry.value * z
        fold entry(m.entry, maxRow, maxColumn)
    }
    fold matrix(m, maxRow, maxColumn)
}

requires matrix(m, maxRow, maxColumn)
ensures matrix(m, maxColumn, maxRow)
ensures forall i, j int :: (0 <= i && i < maxRow && 0 <= j && j < maxColumn) ==> LookupL(m, maxColumn, maxRow, i, j) == old(LookupL(m, maxRow, maxColumn, j, i))
func (m *SparseMatrix) transpose(maxRow, maxColumn int) {
    unfold matrix(m, maxRow, maxColumn)
    if (m != nil) {
        m.next.transpose(maxRow, maxColumn)
        unfold entry(m.entry, maxRow, maxColumn)
        tmp := m.entry.row
        m.entry.row = m.entry.column
        m.entry.column = tmp
        fold entry(m.entry, maxColumn, maxRow)
    }
    fold matrix(m, maxColumn, maxRow)
}
